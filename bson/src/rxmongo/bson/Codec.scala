/*
 * Copyright © 2015 Reactific Software LLC. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rxmongo.bson

import akka.util.{ ByteString, ByteStringBuilder, ByteIterator }

import scala.util.{ Failure, Success, Try }

/** Coder/Decoder (Codec) between type T and BSON Binary format
  *
  * RxMongo users can implement this trait as an implicit object so that their types, T, can be converted into
  * BSON and back. The conversion here completely bypasses the BSON representation and works directly with ByteIterator
  * and BSONBuilder. Alternatively, Codec instances can be generated by the RxMongo macros which makes using the
  * Codec with case classes as simple as a one line declaration of an implicit value.
  *
  * Codecs can only create whole BSON documents which means either an object or an array. For smaller bson types,
  * utilize a BSONBuilder directly.
  *
  * @tparam T The type from which this Codec encodes and to which it decodes
  */
trait Codec[T] {

  /** Convert ByteIterator Into T
    *
    * @param value The ByteIterator from which the value for T is read
    * @return A T that results from reading T from the ByteIterator
    */
  def read(value : ByteIterator) : T

  /** Convert T into BSONValue
    *
    * @param value The value, T, to be written to the builder
    * @param builder The ByteStringBuilder to which the value of type T should be written
    * @return The ByteStringBuilder
    */
  def write(value : T, builder : ByteStringBuilder) : ByteStringBuilder

  def write(value : T, sizeHint : Int = 512) : ByteString = {
    val bsb = ByteString.newBuilder
    bsb.sizeHint(sizeHint)
    write(value, bsb).toByteString
  }

  /** Convenience method to get an Option[T]
    * @param value BSONValue to be converted to T
    * @return None if the value cannot be read, Some[T] otherwise
    */
  def readOption(value : ByteIterator) : Option[T] = Try {
    Option(read(value))
  } match {
    case Success(x) ⇒ x
    case Failure(x) ⇒ None
  }

  /** Convenience method to get an Option[BSONValue]
    *
    * @param value The value, T, to write to BSON
    * @return None if T cannot be written, Some[BSONValue] otherwise
    */
  def writeOption(value : T, sizeHint : Int = 512) : Option[ByteString] = Try {
    Option(write(value, sizeHint))
  } match {
    case Success(x) ⇒ x
    case Failure(x) ⇒ None
  }

  def tryRead(value : ByteIterator) : Try[T] = Try {
    Option(read(value)) match {
      case Some(x) ⇒ x
      case None    ⇒ throw new UnsupportedOperationException(s"Could not decode $value")
    }
  }

  def tryWrite(value : T, sizeHint : Int = 512) : Try[ByteString] = Try {
    Option(write(value, sizeHint)) match {
      case Some(x) ⇒ x
      case None    ⇒ throw new UnsupportedOperationException(s"Could not encode $value")
    }
  }

}

object Codec {

  implicit object BSONObjectCodec extends Codec[BSONObject] {
    def read(value : ByteIterator) : BSONObject = { value.getObject }
    def write(value : BSONObject, builder : ByteStringBuilder) : ByteStringBuilder = { builder.putObject(value); builder }
  }

  implicit object BSONArrayCodec extends Codec[BSONArray] {
    def read(value : ByteIterator) : BSONArray = { value.getArray }
    def write(value : BSONArray, builder : ByteStringBuilder) : ByteStringBuilder = { builder.putArray(value); builder }
  }

}
